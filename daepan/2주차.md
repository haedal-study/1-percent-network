# 2주차

## DNS가 무엇인지 설명해주세요
* Domain Name System의 약자로, 인터넷에서 도메인 이름(Domain Name)을 IP 주소로 변환하거나 IP 주소를 도메인 이름으로 변환하는 서비스(System)이다.</br>
* 인터넷 상의 모든 장치는 IP 주소를 사용하여 서로를 구별하고 통신합니다.
하지만 사람들에게는 숫자로 이루어진 IP 주소보다는 *텍스트 기반의 도메인 이름*이 기억과 사용하기 편리하다는 이점이 있습니다.
* DNS는  *도메인 이름과 IP 주소 간의 변환 역할을 담당*하여 인터넷 사용자가 텍스트 기반의 웹 주소를 사용할 수 있게 해줍니다.

## DNS 서버의 동작방식에 대해 설명해주세요
* DNS 기본 동작 방식은 클라이언트에서 조회메시지를 받고 메시지의 내용을 응답하는 흐름을 가집니다.

## 조회 메세지에는 어떤 정보가 담겨 있나요?
조회 메세지는 크게 3가지 정보가 담깁니다.
* 첫 번쨰로는 이름, 서버나 메일 배송 목적지를 의미합니다.
* 두 번째로는 클래스, 인터넷 외의 네트워크에서 사용하기 위해 존재했던 항목이지만, 현재는 인터넷 외에는 사용하지 않기에 IN이라는 값이 들어있습니다.
* 세번째로는 타입, 이름에 어떤 타입의 정보가 지원되는지를 의미한다. 예를 들어 A인 경우에는 IP 주소가 지원되는 것, MX는 메일 배송 목적지를 지원한다고 할 수 있다.
* 이 타입에 따라 응답값이 결정됩니다.


*요청*: 사용자가 웹 브라우저에 도메인 이름을 입력하면, 먼저 사용자의 컴퓨터에 저장된 로컬 DNS 캐시를 확인하여 해당 도메인의 IP 주소가 있는지 확인합니다. </br>

*재귀적 조회*: 로컬 캐시에 정보가 없으면, 설정된 DNS 서버(주로 인터넷 서비스 제공자(ISP)에서 제공)에게 요청을 보냅니다. 이 DNS 서버는 필요한 정보를 가지고 있지 않으면 다른 DNS 서버에 조회를 요청하는 재귀적인 과정을 거칩니다. </br>

*루트 서버*: DNS 서버는 루트 서버부터 시작하여 TLD(Top-Level Domain) 서버, 그리고 마지막으로 도메인의 권한 있는 이름 서버에 요청을 보내 IP 주소 정보를 얻습니다. </br>

*응답*: 권한 있는 이름 서버에서 해당 도메인의 IP 주소를 찾게 되면, 이 정보는 처음 요청을 시작한 DNS 서버로 전달되고, 그 후 사용자의 컴퓨터로 반환됩니다. </br>

*캐싱*: IP 주소가 확인되면, 이 정보는 일정 시간 동안 로컬 DNS 캐시에 저장됩니다. 이는 같은 요청이 반복될 때 빠른 응답을 가능하게 합니다. </br>

## 도메인 계층 포함된 설명
* 도메인의 계층 구조:
  * *루트 도메인 (*.*)*: DNS 계층의 최상위에 있습니다. 모든 도메인 이름의 맨 끝에 암묵적으로 있는 점(.)으로 생각할 수 있습니다.  </br>
  * *TLD (Top-Level Domain)*: .com, .net, .org, .gov, .country-code 등의 도메인들입니다. 각 국가에는 자신만의 TLD가 있습니다 (예: .us, .uk, .kr 등). </br>
  * *SLD (Second-Level Domain)*: 이는 사용자가 등록하는 도메인 이름의 부분입니다. 예를 들면, google in http://www.google.com. </br>
  * *서브 도메인 (Subdomain)*: SLD 앞의 부분입니다. 예를 들면, www in http://www.google.com. </br>

### DNS 동작 방식 (도메인 계층 관점에서):
* *사용자 요청*: 사용자가 웹 브라우저에 http://www.example.xn--com-of0o 입력하면, DNS 조회가 시작됩니다.  </br>
* *루트 서버 조회*: 처음에는 루트 DNS 서버가 조회됩니다. 루트 서버는 TLD 서버의 주소를 알려줍니다. </br>
* *TLD 서버 조회*: 루트 서버에 의해 제공된 정보를 바탕으로, TLD 서버 (.com 서버 in our example)가 조회됩니다. TLD 서버는 해당 도메인의 권한 있는 (authoritative) 서버의 주소를 알려줍니다. </br>
* *권한 있는 DNS 서버 조회*: TLD 서버에 의해 제공된 정보를 사용하여, example.com에 대한 권한 있는 DNS 서버가 조회됩니다. 이 서버는 http://www.example.xn--com-yh0o IP 주소를 알려줍니다. </br>
* *응답*: 권한 있는 서버의 IP 주소 정보가 사용자의 컴퓨터나 로컬 DNS 서버로 반환됩니다.  </br>

## DNS의 동작 방식이 빠른 이유는?
* *캐싱 (Caching)*:
DNS 조회 결과는 일정 시간 동안 캐시됩니다. 따라서 한 번 조회된 도메인 이름의 IP 주소 정보는 재조회 없이 캐시에서 빠르게 가져올 수 있습니다.
로컬 컴퓨터, 라우터, ISP의 DNS 서버 등 여러 위치에 캐싱이 일어납니다.
이 캐싱 메커니즘 덕분에 대부분의 DNS 조회는 실제로 전 세계적인 DNS 시스템을 통해 진행되지 않아도 됩니다.
* *분산된 서버 구조*:
DNS는 계층적이고 분산된 구조를 가지고 있습니다. 전 세계에 수천 개의 DNS 서버가 위치해 있으며, 각 서버는 특정 부분의 DNS 네임스페이스를 담당합니다.
이 구조는 단일 지점에서의 실패나 병목 현상을 방지하고, 사용자 근처의 서버에서 빠르게 응답을 받을 수 있게 합니다.
* *부하 분산 (Load Balancing)*:
큰 웹 서비스나 인터넷 서비스 제공자 (ISP)는 종종 여러 DNS 서버를 운용하여 요청에 대한 부하를 분산시킵니다. 이는 서비스의 안정성을 높이며, 응답 시간을 줄입니다.
* *최적화 및 효율적인 알고리즘*:
DNS 서버 소프트웨어는 연속적인 개선과 최적화를 거쳐왔습니다. 효율적인 알고리즘과 최적화된 코드 덕분에 DNS 조회는 매우 빠르게 처리됩니다.
* *Anycast*:
  * Anycast는 여러 서버가 동일한 IP 주소를 공유하는 방식입니다. 사용자의 DNS 요청은 가장 가까운, 혹은 가장 응답이 빠른 서버로 자동적으로 전달됩니다.
  * 이 기술을 사용하는 DNS 서비스 (예: Google Public DNS)는 전 세계 여러 지점에서 서비스를 제공하여, 지리적으로 떨어진 사용자에게도 빠른 응답을 보장합니다.
</br> 

## 데이터 송 수신 과정에 대해 설명해주세요
데이터를 송신하는 과정에서는 클라이언트와 서버간의 파이프라인을 연결하는 것과 같다. </br>
데이터를 통신하는 서로의 TCP 소켓을 연결하여 해당 파이프를 통해 양방향에서 데이터를 송신하는 것이 가능하다는 것이다. </br>
즉, 데이터 통신을 위해서는 이런 파이프를 시공하는 작업이 필요하다는 것이다. </br>

### 소켓 작성 방법
소켓 생성과정은 소켓 라이브러리의 일부에서 socket을 호출하여 진행되게 된다. </br>
socket 연결에 대한 정보를 디스크립터라는 형태로 소켓에 대한 정보를 메모리에 저장합니다. </br>

> 디스크립터란? </br>
> 각 소켓에 할당되어 소켓을 식별하는 번호

### 파이프 연결 접속 단계
파이프 연결 접속에 관련해서는 connect라는 함수를 활용해서 진행이 됩니다. </br>
소켓 작성 시에 생성된 디스크립터의 정보를 기반해서 서버와 연결활 소켓을 지정합니다. </br>
connect를 호출할 때 3가지 매개변수를 이용하는데,
1. 클라이언트에서 사용할 소켓 정보를 담고 있는 디스크립터
2. 송수신하는 상대 서버의 IP 주소
3. 접속하는 서버의 소켓을 식별하기 위한 포트 번호
가 필요하다

### 메시지를 주고 받는 송 수신 단계
위의 connect를 통해 파이프라인이 생성되면, 애플리케이션이 소켓을 직접 다룰 수 있으므로 </br> 소켓라이브러리에서의 write 함수를 통해 송신 데이터를 메모리에 준비합니다. </br> 
사용자가 입력한 URL을 바탕으로 HTTP 리퀘스트 메시지를 생성합니다. </br> 
</br> 
그리고 이 메시지에 대한 응답을 받는 과정이 수신과정입니다. </br> 
수신 시에는 read 함수를 통해 수신동작을 진행하는데, 수신한 응답 메세지를 저장하는 메모리를 </br> 
수신 버퍼라고 한다. </br> 
이 수신버퍼가 특수한 이유는 저장하는 메모리의 위치가 애플리케이션 프로그램 내부에 마련된 메모리 </br> 영역이므로 수신버퍼에 저장된 시점에 애플리케이션으로 전달이 가능하다. </br> 
</br> 

### 연결 끊기 단계
연결 끊기 단계에서는 송 수신 단계가 종료되며, 소켓 라이브러리의 close를 호출하여 진행됩다. </br> 
이 때 해제 동작은 응답메세지 송신이 완료되면 웹 서버측에서 close를 호출하여 연결을 종료하며 </br> 
클라리언트 측에 전달을 받게되어 클라이언트의 소켓은 연결 끊기 단계를 준비하게 되고 </br> 
read로 수신동작을 의뢰했을때 read는 수신한 데이터를 건네주는 대신 송 수신 동작이 완료되어 연결이 </br>  끊겼다는 사실을 브라우저에게 알립니다. </br> 
이렇게 송수신이 완료되면 브라우저는 close를 통해 연결 끊기를 진행합니다. </br>  
</br> 
</br> 

## TCP 연결 절차: 3-way handshake
3-way handshake는 TCP 연결을 시작할 때 연결 설정 과정을 설명하는 명칭이다.
3번의 절차를 진행하는데 SYN, SYN-ACK, ACK가 진행된다.

### 3-way handshake의 순서

1. SYN: 클라이언트가 서버로 SYN(Synchronize) 패킷을 전송합니다. 이 패킷은 클라이언트가 연결을 시작하고자 함을 알리며, 클라이언트의 초기 시퀀스 번호를 포함하고 있습니다.

2. SYN-ACK: 서버가 클라이언트로부터의 SYN 패킷을 받으면, SYN과 ACK(Acknowledgment) 플래그가 설정된 패킷을 클라이언트에게 보냅니다. 이 패킷은 서버의 초기 시퀀스 번호와 클라이언트의 SYN 패킷에 대한 응답을 포함하고 있습니다.

3. ACK: 클라이언트가 서버로부터 SYN-ACK 패킷을 받으면, ACK 패킷을 서버에게 보냅니다. 이 ACK 패킷은 서버의 SYN-ACK 패킷에 대한 응답을 나타냅니다.

이 3-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 완료되었음을 증명하며, 양쪽의 데이터 전송이 시작될 수 있는 상태가 됩니다.

## TCP 해제 절차: 4-way handshake
4-way handshake는 TCP 연결을 해제할 때 해제 과정을 설명하는 명칭이다.
4번의 절차가 진행되는데 FIN, ACK, FIN, ACK 4번의 절차가 진행된다.
</br>

### 4-way handshake의 순서

1. FIN: 클라이언트(또는 서버)는 연결을 종료하고자 할 때 FIN(Finish) 플래그가 설정된 패킷을 상대방에게 전송합니다. 이는 "더 이상 전송할 데이터가 없으므로 연결을 종료하고자 함"을 의미합니다.

2. ACK: 상대방(이 예제에서는 서버)은 FIN 패킷을 받았다는 것을 확인하기 위해 ACK(Acknowledgment) 플래그가 설정된 패킷을 보냅니다. 이 패킷은 FIN 패킷에 대한 응답으로, "FIN 패킷을 받았습니다"를 의미합니다.

3. FIN: 이제 서버(또는 클라이언트)는 자신의 데이터 전송이 모두 완료되었음을 알리기 위해 FIN 플래그가 설정된 패킷을 클라이언트에게 전송합니다.

4. ACK: 클라이언트는 서버의 FIN 패킷을 받았다는 것을 확인하기 위해 ACK 패킷을 서버에게 보냅니다. 이 패킷은 서버의 FIN 패킷에 대한 응답으로, "서버의 FIN 패킷을 받았습니다"를 의미합니다.
</br>

이 4-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 안전하게 종료되는 것을 보장하며 
양쪽 모두가 데이터 전송이 완료되었음과 연결이 종료되었음을 알 수 있게 해준다.

## 번외 HTTPS
HTTPS는 HTTP에 **SSL 또는 TLS 프로토콜을 사용하여 통신 내용을 암호화하는 통신 규약**이다.
</br>

> 위의 SSL과 TLS는 명확하게 다른 것이다.
> * SSL은 웹 브라우저와 서버간의 암호화된 통신을 제공하기 위해 만들어진 최초의 프로토콜이다.
> * TLS는 SSL의 직접적인 후속 버전으로 보안 개선 및 프로토콜의 표준화를 목적으로 개선된 프로토콜이다.
</br>

위에서의 TCP 연결과정에서 3way-handshake 이후에 SSL/TLS Handshake를 추가한 것이 HTTPS라고 한다. </br>
</br>

* SSL/TLS HandShake란? 

  - 이 과정은 보안 연결을 설정하기 위해 필요하며, 클라이언트와 서버 사이에서 서로의 신원을 확인하고 암호화 방법을 협상하는 단계이다.
  - 이를 통하 중간자 공격이나 데이터 변조 등의 위협에서 안전할 수 있다.
</br>

1. 사용자가 웹 브라우저에 HTTPS URL을 입력하면, 웹 브라우저는 서버에 SSL 또는 TLS 연결을 요청합니다.
2. 서버는 브라우저에 공개 키가 포함된 인증서를 전송합니다.
3. 웹 브라우저는 이 인증서의 유효성을 확인합니다. 유효하다면, 브라우저는 서버의 공개 키를 사용하여 임시의 세션 키를 암호화하여 서버에 전송합니다.
4. 서버는 자신의 개인 키를 사용하여 세션 키를 복호화합니다. 이제 서버와 클라이언트는 동일한 세션 키를 가지게 되어, 암호화된 데이터 교환을 시작합니다.
</br>

여기서 보안키와 관련된 내용이 많은데, 대칭키 암호화, 비대칭 키 암호화 같은 정보들을 내포하고 있다.
이에 대한 추가적인 조사는 다음주차에 추가적으로 조사하기...

## 퀴즈

1. https://www.cyber.co.kr은 무엇을 나타냅니까?
  * www.cyber.co.kr 서버에 https 프로토콜을 통해 데이터를 불러온다는 내용을 담고 있다.
  * 이는 URL이라고 하며, 웹 상의 데이터들의 위치를 특정할 수 있는 정형화된 문자열이라는 뜻을 갖고 있다.
</br>

2. 다음 URL의 차이는?
> 1. http://www.cyber.co.kr/sample </br>
> 2. http://www.cyber.co.kr/sample/

  * 첫 번째 문자열은 www.cyber.co.kr 웹 서버에서의 sample이라는 파일을 불러올 것이고
  * 두 번째 문자열은 www.cyber.co.kr 웹 서버에서의 sample 폴더에서의 index.html 혹은
default.html을 불러올 것이다.
</br>

3. 인터넷에 접속한 PC나 서버를 식별하기 위해 이용하는 주소는 무엇이라고 하나요?
  *  IP 주소
</br>

4. 웹 서버의 이름을 IP 주소를 조사하기 위해 사용하는 서버를 무엇이라고 하나요?
  * DNS 서버
</br>

5. DNS 서버에서 조회메시지를 보내는 프로그램을 무엇이라고 하는가?
  * DNS 리졸버
</br>

## 리졸버의 개념, ARP와 DNS의 차이
</br>

책에서의 대화 내용을 보면 ARP와 DNS 서버의 통신 방식과 결과 값을 받아내는 것이 크게 다르지 않은데
어째서 리졸버라는 개념이 DNS에서만 존재하는 것인가에 대한 내용으로 해석하였다.
</br></br>

먼저 ARP와 DNS 서버동작에 대한 내용을 비교해보면
  * ARP는 IP주소를 해당 네트워크 장치의 MAC 주소로 변환
  * DNS는 도메인이름을 IP주소로 변환
</br></br>

이렇게 보면 비슷해보이지만 동작방식을 보면 이것이 다르다는 것을 알 수 있습니다. </br>
DNS는 여러 DNS 서버를 거치면서 정보를 조회하는 재귀적 조회가 이루어져 질의 시작점 </br>
즉, 조회 메시지를 생성하는 리졸버가 필수적으로 요구됩니다.
</br></br>

하지만 ARP의 경우에는 단순한 브로드캐스트 메시지를 통해 모든 장치에 이 IP 주소를 가진 장치의 </br> 
MAC주소를 물어보게 되어 해당 IP를 가지고 있는 장치의 응답을 받는 방식으로 동작합니다. </br>
