# 3주차
</br>

## 1. 소켓을 작성한다.
프로토콜 스택 + 네트워크용 하드웨어를 통한 네트워크 방식에 대해  자세히 알아보자 </br>
</br>

계층적인 구조라는 것을 생각했던 것은?

</br>

최상단 애플리케이션 계층에서는
네트워크 애플리케이션과 Socket 라이브러리들이 존재하며 동작과 관리하며, DNS 조회과정이 발생한다.
</br>

OS에서의 프로토콜 스택에서 
TCP를 사용하여 데이터 송수신을 담당하는 부분과 UDP라는 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재하는데.
</br>

### 패킷이란?

- 인터넷에서 데이터를 운반할 때 데이터를 나눈 하나의 형태
</br>



### ICMP, ARP
- IP 안에서 이용되는
* ICMP 
  * 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 이용되는 프로토콜
* ARP
  * IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용하는 프로토콜

</br>

### MAC 주소
- IEEE에서 표준화된 LAN 방식의 기기들이 사용하는 주소
</br>

### LAN이 무엇인가?
* Local Area Network"의 약어로, 
  * 한정된 지리적 영역 내에서 컴퓨터 및 기타 네트워크 기기들이 연결되어 있는 네트워크를 가리킨다.
  * LAN은 주로 가정, 사무실, 학교 등 작은 지역 내에서 컴퓨터나 기기들 간의 데이터 통신을 말한다.
</br>


## 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다.
프로토콜 스택은 내부에 하나의 메모리 영역을 활용하여 통신동작 제어에 필요한 정보를 저장한다.
- 여기서 저장되는 정보는 수신 상대의 IP, 포트 번호, 통신 진행 상태 등이다.
=> 이를 소켓 정보라고 한다.

</br>

프로토콜 스택은 위의 소켓 정보를 활용하여 데이터 통신을 하게된다.
</br>

하지만 이 과정에서 응답이 돌아와야하는데 중간에 응답이 없어지거나 손실되는 경우가 있을 것이다.
그래서 소켓정보에 앞서 말했듯 통신 진행 정보 상태에는 응답이 돌아오는지의 여부와 송신 동작 후의 경과 시간을 확인하여
정보를 포기하거나 다시 보내는 동작을 실행하게 된다.
</br>

> 위에 예시처럼 프로토콜 스택은 소켓에 기록된 제어정보를 참조하여 움직인다.
</br>

### PID
Process ID의 약자로,
각 프로그램을 식별하기 위해 OS가 할당하는 번호
</br>

## Socket 호출 과정
소켓 호출이 이루어지면 프로토콜 스택 내부에서의 동작을 알아보자
</br>

1. UDP 통신을 통한 DNS 서버에서 IP 정보를 받아온다.

2. TCP 통신을 통해 socket 함수 호출 : 소켓 연결

3. TCP 통신을 통한 write 함수 호출 : 데이터 송신

4. TCP 통신을 통한 read 함수 호출 : 데이터 수신

5. TCP 통신을 위한 close 함수 호출 : 연결 끊기
</br>

위의 통신이 시작되면 소켓 한 개 분량의 메모리 영역을 준비합니다

</br>

이러한 메모리 영역을 통해 소켓이 정보를 담아두고 이 위치를 디스크립터를 애플리케이션을 알려주는 과정이 진행된다.
</br></br>

> 애매하니 한번 정리!
> 소켓: 프로세스간 통신이 가능하도록 하는 엔드포인트
> 소켓 정보: 소켓에서 연결되는 IP 등 소켓 통신에 필요한 정보 및 기록을 저장하는 데이터 정보
> 디스크립터: 운영체제에서 소켓 정보를 식별하기 위한 값
</br>

## 서버에 접속한다는 것은 무엇일까?
서버에 접속한다는 것은 클라이언트에서 데이터 송수신 요청을 서버에 보냄을 시작으로,
서버와 클라이언트 간의 제어정보를 주고 받으며, 데이터가 송수신이 가능하도록 하는 상황을 만든다.
</br>

이 과정에서 데이터 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요한데,
이 메모리 영역을 버퍼 메모리라고 한다.
</br>

그리고 이 버퍼 메모리에 대한 확보가 접속 동작이 실행되는데, 
이 실행을 **접속**한다는 의미를 지닙니다.
</br>


## TCP 헤더에는 제어정보를 배치한다.
</br>

위에서 단순하게 송수신 단계에서의 데이터를 제어하는 하는 것을 제어정보라고 표현하였습니다.
이 제어 정보는 TCP 헤더에 기록되는 제어정보는
</br>

- 송신처 포트번호
- 수신처 포트번호
- 시쿼스 번호 : 해당 패킷의 맨 앞의 위치의 데이터가 송신데이터의 몇번쨰 바이트에 해당하는 송신측에서 수신측에 전달하기 위한 정보
- ACK 번호 : 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에서 전달하기 위한 정보
- 데이터 오프셋 : 헤더의 길이
- 사용하지 않음 : 사용하지 않는 필드
- 컨트롤 비트 : 헤더에 대한 각 제어상의 의미를 표시하는 정보
- 윈도우 : 수신측에서 송신측에 윈도우 사이즈를 알리기 위한 정보
- 체크섬 : 오류 유무 검사 정보
- 긴급 포인터 : 긴급 처리할 데이터의 위치
- 옵션 : 필드 외의 추가적인 제어정보 기록
</br>

헤더의 의미는 데이터에 대한 머리로 데이터를 어떻게 처리하면 되는지 알려주는 명세서라고 생각한다면 좋을 것 같다.
데이터 처리 방식 및 접속하는 부분, 에러 사항을 파악하는 정보마저 모두 헤더에 기록되어 있으니
데이터 처리 과정에서는 헤더를 주목하는 것이 데이터 분석에 용이할 것이다.

</br>

> 통신 동작에 이용하는 제어 정보
> * 헤더에 기입되는 정보
> * 소켓에 기록되는 정보



## 데이터 접속 동작의 시작: syn 의미
그렇다면 위의 패킷 정보를 통해 접속을 진행한다고 가정해보자
* 송신 포트번호와 수신 포트번호를 통해 서버측의 소켓을 지정한다.
</br>

이렇게 소켓이 확정되었다면 이제 접속을 시작하는데 이 떄 **SYN**이라는 컨트롤비트를 1로 변경한다.

</br>

> SYN: 컨트롤 비트 중 하나, SYN의 의미는 Synchronize의 약자로 연결 설정을 담당한다.



# 접속의 의미: 3-way handshake
3-way handshake는 TCP 연결을 시작할 때 연결 설정 과정을 설명하는 명칭이다.
3번의 절차를 진행하는데 SYN, SYN-ACK, ACK가 진행된다.
</br>

### 3-way handshake의 순서
</br>

1. SYN: 클라이언트가 서버로 SYN 컨트롤 비트가 담긴 패킷을 전송한다. 이 패킷은 클라이언트가 연결을 시작하고자 함을 알리며, 클라이언트의 초기 시퀀스 번호를 포함한다.

2. SYN-ACK: 서버가 클라이언트로부터의 SYN 패킷을 받으면, SYN과 ACK 컨트롤 비트 설정된 패킷을 클라이언트에 전송한다. 이 패킷은 서버의 초기 시퀀스 번호와 클라이언트의 SYN 패킷에 대한 응답을 포함한다.

3. ACK: 클라이언트가 서버로부터 SYN-ACK 패킷을 받으면, ACK 패킷을 서버에 전송한다. 이 ACK 패킷은 서버의 SYN-ACK 패킷에 대한 응답을 갖고 있다.

</br>

이 3-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 완료되었음을 증명하며, 양쪽의 데이터 전송이 시작될 수 있는 상태가 된다.
이 데이터 통신이 3번의 절차를 통해 데이터 통신에 대한 안정적으로 연결될 수 있는 것이다.


# 데이터 송수신 과정 
connnect를 사용하여 운반을 패킷을 운반하게 되는데 이떄 패킷을 어떤 데이터를 어느 정도의 크기로 제한해서 보낼지를 정하게 된다.
각 OS마다 패킷에 대한 규격의 크기를 설정하게된다.

패킷 크기에 대한 용어로
> MTU: 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대길이, 이더넷 기준으로 1500바이트이다.</br> 
> MSS: 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP 데이터의 최대길이
가 있다.

**MTU**는 IP헤더 + TCP 헤더 +  데이터 이고,
위 예시에서의 데이터의 최대크기가 **MSS**라는 것이다.

## 송수신 하는 패킷에 대한 고찰
이렇게 패킷이 데이터를 전송하는 형태라는 것은 이해되지만 데이터 전송과 관련해서 전송속도에 대한 고민을 하게 된다.

이 전송 속도와 관련해서는 **가변적인 MSS의 크기**와 **최대전송지연시간을 설정하는 것**이다.
당연하게도 MSS의 크기가 커지게 될 경우 한번 통신에서 많은 데이터르 전송할 수 있어 네트워크의 효율이 높아지기는 하지만,
버퍼에 데이터를 저장하는 등의 추가적인 작업이 커저 전송시간 지연이 늘어날 것이다.
하지만 이 저장하는 과정에서 OS에서 지정한 최대전송지연시간이 경과하면 패킷을 전송하도록 하는 식으로 대처할 수 있다.


이렇게 서로 의미가 상충하기에 이 둘을 잘 고민하여 사용하는 것이 개발자의 몫으로 남아 있다.
- 기회가 된다면 이와 관련된 프로그래밍에 대해 해보고 싶다!

## 데이터 분할을 통한 수신
기본적으로 애플리케이션의 데이터는 위에서 제시했던 1500바이트 보다 훨씬 큰 경우가 매우 매우 많다.
그렇기에 이런 데이터를 분할하여 전송하게된다.

그렇다면 분할하는 방식은 어떻게 될까?

HTTP 데이터 송신 과정을 예로 들어 설명하면 
```
[HTTP 헤더] + [메시지 본문]
```
이렇게 되어 있다면, TCP가 메시지 본문을 분할하여 조각[MSS의 크기]을 생성하고 헤더를 생성한다.
물론 IP 헤더도 같이 작업이 들어갈 것이다.
```
[IP 헤더][TCP 헤더][조각 1]
[IP 헤더][TCP 헤더][조각 2]
[IP 헤더][TCP 헤더][조각 3]
...//
```

그렇다면 이렇게 데이터를 전송하면서 나눠진 데이터를 다시 합치게 될 떄 섞여 있거나 어느것은 잘 도착하고 안했는지 
컴퓨터가 알 수 있게 하기 위해 송신하는 각 데이터마다 시퀀스 번호라는 것을 부여한다.

이 시퀀스 번호는 데이터 조각을 분할할 때 몇번째 바이트에 해당하는지를 알려준다.
그리고 시퀀스 번호와 패킷의 데이터 길이를 더하여 **ACK 번호**를 부여하게된다.

3-way ShakeHand에서 SYN 시작 과정에서 초기 시퀀스 번호를 교환한다는 것은 결국 이 시퀀스 번호부터 데이터를 보내겠다는 의미로 해석하면 된다.
수신자 : '여기(시퀀스 번호)부터 데이터를 줄거야!'
송신자 : OK

그리고 이 ACK를 수신받은 수신자는 다시 송신자에게 이 ACK 번호까지 받았다고 한번 더 수신자에게 수신 확인 응답을 보내게된다.

## 패킷 송수신 과정에서의 오류 복구
패킷 송수신 과정에서 오류가 발생할 경우가 분명 있을 것이다.
그렇다면 이 복구 과정은 어떻게 일어날까?

기본적으로 패킷을 송신하는 호스트는 송신하는 패킷을 송신용 버퍼 메모리에 미리 저장해둔다.
만약 패킷을 송신하고 잘못된 응답, 응답이 없는 경우 송신측에서는 다시 한번 보내어 오류복구를 시도할 것이다.
이렇게 시도하다가 일정 수준 이상의 시도가 지나게 되면 애플리케이션에게 에러처리를 하도록 지시한다.

물론 이 과정에서는 많은 생각이 필요하긴하다.
쪼개진 데이터를 보내고 ACK가 돌아오는 시간을 어느정도로 잡아야하는가를 고민하게된다.
이 시간을 **타임아웃 값**이라고 하는데,
이 값을 너무 늦게 혹은 짧게 할 경우 ACK 통신 과정에서 계속해서 반복적으로 보내게 되는 경우가 있어
수신하는 데이터가 혼잡하게 될 것이다.

그래서 이에 대한 해결방법으로는 초기 연결과정에서 응답 시간에 대해서 돌아오는 시간을 계측하여 예상하는 동적인 방법을 많이 사용한다.


## 데이터 송신 과정: 핑퐁, 윈도우 제어방식

데이터 통신 방식에서 ACK를 통해 데이터가 어디까지 주고 받았는지를 확인하게 되는데,
여기서 두 가지 방식이 있다.

**핑퐁**방식은 데이터 송신 이후 수신 확인 응답이 한 과정이 주고 받고식의 송신이다.
이때 수신 응답 과정에서 응답을 기다리는 과정에서 시간이 낭비된다.

그래서 윈도우 제어방식을 주로 활용하는 것이 좋은데
이 방식은 수신측과 송신측의 메모리 영역을 통해 최대 얼만큼의 데이터를 주고 받을지를 설정하는 것이다.

1. 송신자는 현재 수신자가 사용할 수 있는 메모리 영역의 크기를 받는다.
2. 송신자는 수신자가 준 메모리 영역만큼의 데이터를 송신하다.
3. 수신자는 계속해서 송신되는 데이터들을 처리하고, 응답에 대해서 현재 사용가능한 메모리 영역의 크기를 보내준다.

이렇게 송신자와 수신자 간의 사용가능한 메모리 영역을 주고 받음으로써 계속해서 지연시간을 최소화하는 
방법이 **윈도우 제어방식** 이다.


# 연결 해제와 소켓 말소: 4-way handshake
4-way handshake는 TCP 연결을 해제할 때 해제 과정을 설명하는 명칭이다.
4번의 절차가 진행되는데 FIN, ACK, FIN, ACK 4번의 절차가 진행된다.
</br>

### 4-way handshake의 순서
</br>

1. FIN: 클라이언트(또는 서버)는 연결을 종료하고자 할 때 FIN(Finish) 플래그가 설정된 패킷을 상대방에게 전송한다. 이는 "더 이상 전송할 데이터가 없으므로 연결을 종료하고자 함"을 의미한다.

2. ACK: 상대방(이 예제에서는 서버)은 FIN 패킷을 받았다는 것을 확인하기 위해 ACK(Acknowledgment) 플래그가 설정된 패킷을 보낸다. 이 패킷은 FIN 패킷에 대한 응답으로, "FIN 패킷을 받았습니다"를 의미한다.

3. FIN: 이제 서버(또는 클라이언트)는 자신의 데이터 전송이 모두 완료되었음을 알리기 위해 FIN 플래그가 설정된 패킷을 클라이언트에게 전송힌다.

4. ACK: 클라이언트는 서버의 FIN 패킷을 받았다는 것을 확인하기 위해 ACK 패킷을 서버에게 보낸다. 이 패킷은 서버의 FIN 패킷에 대한 응답으로, "서버의 FIN 패킷을 받았습니다"를 의미한다.
</br>

이 4-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 안전하게 종료되는 것을 보장하며 
양쪽 모두가 데이터 전송이 완료되었음과 연결이 종료되었음을 알 수 있게 해준다.